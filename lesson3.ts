//slice() - вырезает и возвращает указанную часть массива. Сам массив при этом не изменяется. Первым параметром указывается номер элемента массива, с которого начинается вырезание, а вторым параметром - номер элемента, на котором закончится вырезание (при этом элемент с этим номером не включится в вырезанную часть). Второй параметр не является обязательным. Если его не указать - подмассив возьмется с указанного в первом параметре элемента до конца массива.

//Он также может принимать отрицательные значения. В этом случае отсчет элемента, на котором закончится обрезание, начинается с конца массива. Последний элемент при этом будет иметь номер -1.

//Общая схема, использования данного метода выглядит примерно вот так:

//массив.slice(откуда отрезать, [докуда отрезать]);

//Рассмотрим детальнее данный метод на примерах:

//Давайте вырежем элементы с нулевого по второй не включительно(второй не вырезается)

//js
let arr1 = ['a', 'b', 'c', 'd', 'e']
let sub = arr1.slice(0, 2)
 
console.log(arr) // [ 'a', 'b', 'c', 'd', 'e' ]
console.log(sub) // [ 'a', 'b' ]
//Давайте вырежем с первого элемента и до конца массива. Для этого мы второй параметр не задаем

//js
let arr2 = ['a', 'b', 'c', 'd', 'e']
let sub2 = arr2.slice(1)
 
console.log(sub2) //[ 'b', 'c', 'd', 'e' ]
//Давайте вырежем элементы со второго по предпоследний (-1 указывает на последний элемент и он не включится в извлеченную часть):

//js
let arr3 = ['a', 'b', 'c', 'd', 'e']
let sub3 = arr3.slice(1, -1)
 
console.log(sub3) // [ 'b', 'c', 'd' ]

//splice() - удаляет или добавляет элементы в массив. Можно только удалять элементы, только добавлять или делать и то и другое одновременно. Метод очень универсальный и сложный для понимания. Метод изменяет сам массив и возвращает при этом массив удаленных элементов.

//Первым параметром метод принимает номер элемента массива, который нужно удалить. Вторым параметром - сколько элементов массива следует удалить. Если его поставить в 0 - то элементы удалены не будут (только добавлены новые). Дальше через запятую идут элементы, которые нужно добавить в массив (являются необязательными параметрами). Эти элементы добавятся вместо удаленных элементов массива.

//Если удаления не было (когда второй параметр 0) - элементы вставляются в массив начиная с той позиции, которая указана первым параметром метода. Первый параметр может иметь отрицательное значение. В этом случае отсчет позиции начнется не с начала массива, а с конца. Последний элемент при этом будет иметь номер -1.

//Общая схема данного метода массива:

//массив.splice(откуда удаляем, сколько удаляем, [вставить], [вставить]...);

//Давайте удалим три элемента, начиная с первого:

//js
let arr4 = ['a', 'b', 'c', 'd', 'e']
arr4.splice(1, 3)
 
console.log(arr4) //[ 'a', 'e' ]
//Давайте выведем массив удаленных элементов:

//js
let arr5 = ['a', 'b', 'c', 'd', 'e']
let del = arr5.splice(1, 3)
 
console.log(del) //[ 'b', 'c', 'd' ]
//Давайте теперь ничего не будем удалять, но на позицию 2, вставим еще три новых элемента:

//js
let arr6 = ['a', 'b', 'c', 'd', 'e']
arr6.splice(2, 0, '1', '2', '3')
 
console.log(arr6) // ['a', 'b', '1', '2', '3', 'c', 'd', 'e']
//Давайте удалим предпоследний элемент:

//js
let arr7 = ['a', 'b', 'c', 'd', 'e']
arr7.splice(-2, 1)
 
console.log(arr7) //[ 'a', 'b', 'c', 'e' ]


//toSpliced() - такой же метод, как и splcie, но он у нас иммутабельный, вышел относительно недавно, поэтому не везде может поддерживаться (надо смотреть в каких средах поддерживается)

//js
const months = ['Jan', 'Mar', 'Apr', 'May']
 
// Вставляем элемент по 1 индексу
const months2 = months.toSpliced(1, 0, 'Feb')
console.log(months2) // ["Jan", "Feb", "Mar", "Apr", "May"]
 
// Удаляем два элемента, начиная со 2 индекса
const months3 = months2.toSpliced(2, 2)
console.log(months3) // ["Jan", "Feb", "May"]
 
// Заменяем один элемент под 1-м индексом двумя новыми элементами
const months4 = months3.toSpliced(1, 1, 'Feb', 'Mar')
console.log(months4) // ["Jan", "Feb", "Mar", "May"]
 
// Оригинальный массив остался прежним
console.log(months) // ["Jan", "Mar", "Apr", "May"]


//reduce() - применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

//Давайте начнем с простого примера, где будем вычислять сумму элементов в массиве. Как обычно мы бы делали это? Перебором через цикл for

//js
let a1 = [1, 2, 3, 4, 5]
let sum = 0
 
for (let i = 0; i < a1.length; i++) {
  sum = sum + a1[i]
}
 
console.log('sum', sum) //15
//Если мы видим подобную конструкцию, где есть цикл для перебора массива и есть переменная за пределами, которая вычисляется, то скорее всего вам reduce подойдет

//сейчас давайте пару минут нудной теории, reduce - это метод, который позволяет применять функцию к массиву, причем применяет ее следующим образом. Функция коллбэк у нас имеет несколько параметров это prev предыдущее или правильнее сказать вычисляемой значение, item и необязательный это index номер элемента в массиве

//prev - это вычисляемое значение. Чему оно равно до старта? до старта оно равняется нулевому элементу массива (arr[0]), если мы не укажем сами, т..е в первый момент времени, в первом круге перебору равен нулевому элемента массива, либо мы можем указать через запятую чему будет на старте равно наше вычисляемое значение

//В начальный момент сумма равна 0, как мы видим из предыдущего примера, поэтому я через запятую указываю, что наш prev на первом кругу будет равен 0.

//Что я должна делать внутри функции(коллбэке), раз prev вычисляемое значение, то я должна написать return и возвратить вычисляемое значение prev + item (элемент текущего массива)

//js
let a = [1, 2, 3, 4, 5]
let b1 = a.reduce(function (prev, item, index) {
  return prev + item
}, 0)
 
console.log('b', b1) //15
//Также мы с вами можем упростить наш reduce:

//js
let b = a.reduce((prev, item, index) => prev + item, 0)
//Теперь давайте рассмотрим пример с объектами. Представим, у нас есть массив объектов с информацией о фруктах:

//Здесь мы используем reduce, чтобы сложить количество каждого фрукта в массиве.

//Аналогия, чтобы лучше понять: давайте представим, что у вас есть коробка с конфетами, и каждая конфета - это элемент массива. Reduce - это как подсчет общего количества конфет в коробке.

//js
const fruits = [
  { name: 'apple', quantity: 2 },
  { name: 'banana', quantity: 3 },
  { name: 'orange', quantity: 1 },
]
 
const totalQuantity = fruits.reduce((accumulator, fruit) => accumulator + fruit.quantity, 0)
 
console.log(totalQuantity) //6
//Давайте дальше разберем с вами пример нахождение максимального значения в массиве чисел:

//Функция обратного вызова принимает два аргумента: max - аккумулированное максимальное значение и current - текущий элемент массива. Если текущий элемент больше аккумулированного максимального значения, то он становится новым максимальным значением.

//js
const numbers = [5, 2, 8, 1, 6]
const maxNumber = numbers.reduce((acc, current) => (current > acc ? current : acc), numbers[0])
console.log(maxNumber) // Выведет 8
//Далее рассмотрим задачку объединение значений объектов массива:

//acc.names.push(person.name); - добавляет имя текущего человека в массив names аккумулированного значения. acc.totalAge += person.age; - увеличивает общий возраст на возраст текущего человека.

//js
const people1 = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 22 },
] // { names: [...], totallAge: ..}
 
const combinedInfo = people1.reduce(
  (acc, person) => {
    console.log('person', person)
    acc.names.push(person.name)
    acc.totalAge += person.age
    return acc
  },
  { names: [], totalAge: 0 }
)
 
console.log(combinedInfo) // { names: [ 'Alice', 'Bob', 'Charlie' ], totalAge: 77 }
//Давайте реализуем эту задачу через map и сравним результаты с использованием reduce. В этом примере, мы создадим два массива: один с именами (names) и второй с возрастами (ages). Затем мы посчитаем общий возраст.

//js
const people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 22 },
] // { names: [...], totallAge: ..}
 
const mappedInfo = people.map(person => ({
  name: person.name,
  age: person.age,
}))
 
console.log('mappedInfo', mappedInfo) // mappedInfo [ { name: 'Alice', age: 25 },  { name: 'Bob', age: 30 },  { name: 'Charlie', age: 22 } ]
 
const combinedInfoMap = {
  names: mappedInfo.map(person => person.name),
  totalAge: mappedInfo.reduce((acc, person) => acc + person.age, 0),
}
 
console.log(combinedInfoMap) // { names: [ 'Alice', 'Bob', 'Charlie' ], totalAge: 77 }
//Итого:

//Используйте map, когда вам нужен новый массив с измененными значениями.

//Используйте reduce, когда вам нужно объединить значения массива в одно окончательное значение.